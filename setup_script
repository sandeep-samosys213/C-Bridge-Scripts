#!/bin/bash

# =============================================================================
# C-Bridge Complete Setup Script for Raspberry Pi
# =============================================================================
# This script sets up EVERYTHING needed for C-Bridge on a fresh Raspberry Pi
# Including: Node.js, PostgreSQL, TimescaleDB, Docker, Mender OTA, SD Encryption,
# Firebase, GPIO/Serial, Security, Monitoring, and the complete application
# =============================================================================

set -e  # Exit on any error

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
PURPLE='\033[0;35m'
CYAN='\033[0;36m'
NC='\033[0m' # No Color

# Configuration
# Use current directory instead of /opt/cbridge for dev setup
SCRIPT_DIR="$( cd "$( dirname "${BASH_SOURCE[0]}" )" && pwd )"
APP_DIR="${SCRIPT_DIR}"
APP_USER="$USER"

# Detect Raspberry Pi's IP address dynamically
detect_ip_address() {
    # Get the primary IP address (excluding localhost and docker IPs)
    local ip=$(hostname -I | awk '{print $1}')
    
    # Fallback to specific interface if hostname -I doesn't work
    if [ -z "$ip" ] || [ "$ip" = "127.0.0.1" ]; then
        ip=$(ip route get 8.8.8.8 2>/dev/null | grep -oP 'src \K\S+')
    fi
    
    # Final fallback to localhost if no network
    if [ -z "$ip" ]; then
        ip="127.0.0.1"
    fi
    
    echo "$ip"
}

# Detect and store IP address
PI_IP_ADDRESS=$(detect_ip_address)

# Database credentials will be loaded later in setup_database_credentials function
DB_NAME=""
DB_USER=""
DB_PASSWORD=""

# Generate unique JWT secrets for each installation
JWT_SECRET="$(openssl rand -hex 32)"
JWT_REFRESH_SECRET="$(openssl rand -hex 32)"
ENCRYPTION_KEY="$(openssl rand -hex 32)"
FILE_ENCRYPTION_KEY="$(openssl rand -hex 32)"

# Store credentials for later use
CREDENTIALS_FILE="/tmp/cbridge_credentials_$(date +%s).txt"
echo "# C-Bridge Installation Credentials - $(date)" > $CREDENTIALS_FILE
echo "PI_IP_ADDRESS=$PI_IP_ADDRESS" >> $CREDENTIALS_FILE
echo "DB_NAME=$DB_NAME" >> $CREDENTIALS_FILE
echo "DB_USER=$DB_USER" >> $CREDENTIALS_FILE
echo "DB_PASSWORD=$DB_PASSWORD" >> $CREDENTIALS_FILE
echo "JWT_SECRET=$JWT_SECRET" >> $CREDENTIALS_FILE
echo "JWT_REFRESH_SECRET=$JWT_REFRESH_SECRET" >> $CREDENTIALS_FILE
echo "" >> $CREDENTIALS_FILE
echo "# Access URLs:" >> $CREDENTIALS_FILE
echo "# Frontend: http://$PI_IP_ADDRESS:3000" >> $CREDENTIALS_FILE
echo "# Backend: http://$PI_IP_ADDRESS:5000" >> $CREDENTIALS_FILE

# Mender OTA Configuration
MENDER_TENANT_TOKEN="F910WCSxNayAHd3Q-8XlyA0xnZ8QdAhurvmexk8IFjY"

# Print functions
print_header() {
    echo -e "${PURPLE}==============================================================================${NC}"
    echo -e "${PURPLE}$1${NC}"
    echo -e "${PURPLE}==============================================================================${NC}"
}

print_status() {
    echo -e "${GREEN}‚úÖ $1${NC}"
}

print_warning() {
    echo -e "${YELLOW}‚ö†Ô∏è  $1${NC}"
}

print_error() {
    echo -e "${RED}‚ùå $1${NC}"
}

print_info() {
    echo -e "${BLUE}‚ÑπÔ∏è  $1${NC}"
}

print_step() {
    echo -e "${CYAN}üîß $1${NC}"
}

# Generate and setup database credentials
setup_database_credentials() {
    print_info "Generating unique database credentials for this installation..."
    
    # Generate unique database credentials
    DB_NAME="cbridge_$(openssl rand -hex 4)"
    DB_USER="cbridge_user_$(openssl rand -hex 4)"
    DB_PASSWORD="$(openssl rand -base64 32 | tr -d "=+/" | cut -c1-25)"
    
    print_status "Database credentials generated: DB=$DB_NAME, USER=$DB_USER"
    print_info "These credentials will be saved to .env file"
}

# Check if running as root
check_root() {
    if [ "$EUID" -eq 0 ]; then
        print_error "This script should not be run as root. Please run as a regular user with sudo privileges."
        exit 1
    fi
}

# Check if user has sudo privileges
check_sudo() {
    if ! sudo -n true 2>/dev/null; then
        print_error "This script requires sudo privileges. Please run with sudo access."
        exit 1
    fi
}

# Update system packages
update_system() {
    print_step "Updating system packages..."
    sudo apt update && sudo apt upgrade -y
    sudo apt install -y curl wget git vim htop unzip build-essential python3-dev 2>/dev/null || sudo apt install -y curl wget git vim htop unzip build-essential
    print_status "System packages updated"
}

# Install Node.js 18+
install_nodejs() {
    print_step "Installing Node.js 18+..."
    curl -fsSL https://deb.nodesource.com/setup_18.x | sudo -E bash -
    sudo apt-get install -y nodejs
    sudo npm install -g pm2 nodemon
    print_status "Node.js $(node --version) installed"
}

# Install PostgreSQL and TimescaleDB with proper fixes
install_database() {
    print_step "Installing PostgreSQL and TimescaleDB..."
    
    # Install PostgreSQL
    sudo apt install -y postgresql postgresql-contrib
    
    # Remove any existing TimescaleDB repository that might cause issues
    sudo rm -f /etc/apt/sources.list.d/timescaledb.list
    
    # Install TimescaleDB from official repository with proper error handling
    print_info "Adding TimescaleDB repository..."
    wget --quiet -O - https://packagecloud.io/timescale/timescaledb/gpgkey | sudo tee /usr/share/keyrings/timescaledb.asc > /dev/null
    echo "deb [signed-by=/usr/share/keyrings/timescaledb.asc] https://packagecloud.io/timescale/timescaledb/debian/ $(lsb_release -c -s) main" | sudo tee /etc/apt/sources.list.d/timescaledb.list
    
    # Update package lists
    sudo apt update
    
    # Install TimescaleDB for PostgreSQL 15 (or 14 if 15 not available)
    if sudo apt install -y timescaledb-2-postgresql-15 2>/dev/null; then
        print_status "TimescaleDB 2 for PostgreSQL 15 installed"
    elif sudo apt install -y timescaledb-2-postgresql-14 2>/dev/null; then
        print_status "TimescaleDB 2 for PostgreSQL 14 installed"
    else
        print_warning "TimescaleDB installation failed, continuing without it"
        return 0
    fi
    
    # Tune TimescaleDB
    sudo timescaledb-tune --quiet --yes
    
    # Start and enable PostgreSQL
    sudo systemctl start postgresql
    sudo systemctl enable postgresql
    
    # Create database and user with proper permissions
    print_info "Creating database and user..."
    sudo -u postgres psql -c "CREATE DATABASE $DB_NAME;" 2>/dev/null || print_info "Database $DB_NAME already exists"
    sudo -u postgres psql -c "CREATE USER $DB_USER WITH PASSWORD '$DB_PASSWORD';" 2>/dev/null || print_info "User $DB_USER already exists"
    sudo -u postgres psql -c "GRANT ALL PRIVILEGES ON DATABASE $DB_NAME TO $DB_USER;"
    sudo -u postgres psql -c "ALTER USER $DB_USER CREATEDB;"
    
    # Grant schema permissions (CRITICAL FIX)
    sudo -u postgres psql -d $DB_NAME -c "GRANT ALL ON SCHEMA public TO $DB_USER;"
    sudo -u postgres psql -d $DB_NAME -c "GRANT CREATE ON SCHEMA public TO $DB_USER;"
    
    # Enable TimescaleDB extension if available
    if sudo -u postgres psql -d $DB_NAME -c "CREATE EXTENSION IF NOT EXISTS timescaledb CASCADE;" 2>/dev/null; then
        print_status "TimescaleDB extension enabled"
    else
        print_warning "TimescaleDB extension not available, continuing without it"
    fi
    
    # Enable other required extensions
    sudo -u postgres psql -d $DB_NAME -c "CREATE EXTENSION IF NOT EXISTS \"uuid-ossp\";"
    sudo -u postgres psql -d $DB_NAME -c "CREATE EXTENSION IF NOT EXISTS \"pgcrypto\";"
    
    print_status "PostgreSQL and TimescaleDB installed and configured"
}

# Install Docker and Docker Compose
install_docker() {
    print_step "Skipping Docker installation (dev mode setup)..."
    print_info "Docker should be installed separately using the Docker setup script"
    print_status "Docker setup skipped"
}

# Set up private repository authentication
setup_private_repo_auth() {
    print_step "Setting up private repository authentication..."
    
    echo ""
    print_info "For private GitHub repositories, you need to authenticate Docker to pull images."
    echo ""
    echo "Options:"
    echo "1. GitHub Personal Access Token (recommended)"
    echo "2. Skip authentication (use public repos only)"
    echo ""
    read -p "Choose option (1/2): " auth_option
    
    case $auth_option in
        1)
            echo ""
            print_info "To create a GitHub Personal Access Token:"
            echo "1. Go to GitHub Settings > Developer settings > Personal access tokens"
            echo "2. Generate new token with 'read:packages' permission"
            echo "3. Copy the token"
            echo ""
            read -p "Enter your GitHub username: " github_username
            read -s -p "Enter your GitHub Personal Access Token: " github_token
            echo ""
            
            # Authenticate Docker with GitHub Container Registry
            echo "$github_token" | sudo docker login ghcr.io -u "$github_username" --password-stdin
            
            if [ $? -eq 0 ]; then
                print_status "Docker authenticated with GitHub Container Registry"
                
                # Store credentials securely for future use
                sudo mkdir -p /etc/docker
                echo "ghcr.io" > /tmp/docker_registry
                echo "$github_username" >> /tmp/docker_registry
                sudo mv /tmp/docker_registry /etc/docker/registry_auth
                sudo chmod 600 /etc/docker/registry_auth
                
                print_info "Registry authentication stored securely"
            else
                print_error "Failed to authenticate with GitHub Container Registry"
                print_warning "You may need to manually authenticate later"
            fi
            ;;
        2)
            print_info "Skipping private repository authentication"
            print_warning "You can set this up later with: docker login ghcr.io"
            ;;
        *)
            print_warning "Invalid option. Skipping authentication setup."
            ;;
    esac
}

# Install Mender OTA Client
install_mender() {
    print_step "Checking Mender OTA Client..."
    
    if command -v mender &> /dev/null; then
        print_status "Mender OTA client already installed"
        # Enable and start Mender services if they exist
        sudo systemctl enable mender-authd mender-updated mender-connect mender-monitor 2>/dev/null || true
        sudo systemctl start mender-authd mender-updated mender-connect mender-monitor 2>/dev/null || true
    else
        print_info "Mender OTA not installed - skipping for dev mode"
        print_info "Install Mender separately for production if needed"
    fi
    
    print_status "Mender OTA check complete"
}

# Set up SD Card Encryption
setup_encryption() {
    print_step "Skipping SD Card Encryption setup (dev mode)..."
    print_info "SD Card encryption should be configured separately for production"
    print_info "You can enable it later with: sudo ./backend/scripts/setup-sd-card-encryption.sh"
    print_status "Encryption setup skipped"
}

# Create application user and directory
setup_application() {
    print_step "Setting up application in current directory..."
    
    # We're already in the correct directory, just ensure proper permissions
    # and create necessary subdirectories
    mkdir -p logs uploads
    
    print_status "Application directory structure verified"
}

# Clone repository
clone_repository() {
    print_step "Verifying C-Bridge repository..."
    
    # We're already in the repository directory
    if [ -d ".git" ]; then
        print_status "Git repository detected"
    else
        print_info "Not a git repository, but that's okay for dev setup"
    fi
    
    # Verify required directories exist
    if [ ! -d "backend" ]; then
        print_error "Backend directory not found!"
        exit 1
    fi
    
    if [ ! -d "frontend" ]; then
        print_warning "Frontend directory not found"
    fi
    
    # Check Firebase service account file
    if [ -f "backend/cbridge-1-firebase-adminsdk.json" ]; then
        print_status "Firebase service account file found"
    else
        print_warning "Firebase service account file not found (backend/cbridge-1-firebase-adminsdk.json)"
    fi
    
    print_status "Repository verification complete"
}

# Create environment file with all the fixes
create_environment() {
    print_step "Creating environment configuration..."
    
    # We're already in the correct directory
    # Create environment file with production mode backend (for performance) but dev-friendly settings
    cat > .env << EOF
# ==== FRONTEND ENV ====
NEXT_PUBLIC_API_URL=http://${PI_IP_ADDRESS}:5000
NEXT_PUBLIC_WS_URL=ws://${PI_IP_ADDRESS}:5000

# Firebase Configuration
NEXT_PUBLIC_FIREBASE_API_KEY=AIzaSyD3TdRUub4-yb5O17cfQlNsaLYkC_TM4aE
NEXT_PUBLIC_FIREBASE_AUTH_DOMAIN=cbridge-1.firebaseapp.com
NEXT_PUBLIC_FIREBASE_PROJECT_ID=cbridge-1
NEXT_PUBLIC_FIREBASE_STORAGE_BUCKET=cbridge-1.appspot.com
NEXT_PUBLIC_FIREBASE_MESSAGING_SENDER_ID=280049315285
NEXT_PUBLIC_FIREBASE_APP_ID=1:280049315285:web:d0b83d32bf960b744fe15c
NEXT_PUBLIC_FIREBASE_MEASUREMENT_ID=G-32Q1R8Y3H8
NEXT_PUBLIC_FIREBASE_BYPASS=false

# ==== BACKEND ENV ====
PORT=5000

# JWT Configuration
JWT_SECRET=$JWT_SECRET
JWT_REFRESH_SECRET=$JWT_REFRESH_SECRET

# Serial Port Configuration
SERIAL_PORT_PATH=/dev/serial0
SERIAL_BAUD_RATE=115200
SERIAL_PORT=/dev/serial0  

# Database Configuration
DB_USER=$DB_USER
DB_PASSWORD=$DB_PASSWORD
DB_NAME=$DB_NAME
DB_HOST=localhost
DB_PORT=5432

# TimescaleDB Configuration
TIMESCALE_USER=$DB_USER
TIMESCALE_PASSWORD=$DB_PASSWORD
TIMESCALE_NAME=${DB_NAME}_timescale
TIMESCALE_HOST=localhost
TIMESCALE_PORT=5432

# CORS Configuration
CORS_ORIGIN=http://${PI_IP_ADDRESS}:3000,http://localhost:3000,http://127.0.0.1:3000

# File Upload
UPLOAD_DIR=$APP_DIR/uploads
MAX_FILE_SIZE=5242880

# Logging
LOG_LEVEL=info
LOG_FILE=$APP_DIR/logs/app.log

# API
API_VERSION=v1

# Firebase Admin SDK
GOOGLE_APPLICATION_CREDENTIALS=$APP_DIR/backend/cbridge-1-firebase-adminsdk.json
DISABLE_FIREBASE=false
BYPASS_AUTH=true
NODE_ENV=production

# Docker Database Configuration
POSTGRES_USER=$DB_USER
POSTGRES_PASSWORD=$DB_PASSWORD
POSTGRES_DB=$DB_NAME
NEXT_PUBLIC_DISABLE_FIREBASE=false
NEXT_PUBLIC_DEMO_MODE=false
FIREBASE_SERVICE_ACCOUNT_PATH=./cbridge-1-firebase-adminsdk.json

# ==== MENDER OTA CONFIGURATION ====
MENDER_SERVER_URL=https://hosted.mender.io
MENDER_TENANT_TOKEN=$MENDER_TENANT_TOKEN
MENDER_DEVICE_TYPE=raspberrypi5

# ==== GPIO AND SERIAL CONFIGURATION ====
GPIO_ENABLED=true
UART_ENABLED=true

# ==== SD CARD ENCRYPTION ====
SD_CARD_DEVICE=/dev/mmcblk0
SD_MOUNT_POINT=/mnt/sd_encrypted
ENCRYPTION_KEY=$ENCRYPTION_KEY
FILE_ENCRYPTION_KEY=$FILE_ENCRYPTION_KEY

# ==== NODE WARNINGS SUPPRESSION ====
NODE_NO_WARNINGS=1
EOF

    # Create production environment file template
    cat > .env.production << EOF
# ==== FRONTEND ENV ====
NEXT_PUBLIC_API_URL=http://${PI_IP_ADDRESS}:5000
NEXT_PUBLIC_WS_URL=ws://${PI_IP_ADDRESS}:5000

# Firebase Configuration
NEXT_PUBLIC_FIREBASE_API_KEY=AIzaSyD3TdRUub4-yb5O17cfQlNsaLYkC_TM4aE
NEXT_PUBLIC_FIREBASE_AUTH_DOMAIN=cbridge-1.firebaseapp.com
NEXT_PUBLIC_FIREBASE_PROJECT_ID=cbridge-1
NEXT_PUBLIC_FIREBASE_STORAGE_BUCKET=cbridge-1.appspot.com
NEXT_PUBLIC_FIREBASE_MESSAGING_SENDER_ID=280049315285
NEXT_PUBLIC_FIREBASE_APP_ID=1:280049315285:web:d0b83d32bf960b744fe15c
NEXT_PUBLIC_FIREBASE_MEASUREMENT_ID=G-32Q1R8Y3H8
NEXT_PUBLIC_FIREBASE_BYPASS=false

# ==== BACKEND ENV ====
PORT=5000

# JWT Configuration
JWT_SECRET=$JWT_SECRET
JWT_REFRESH_SECRET=$JWT_REFRESH_SECRET

# Serial Port Configuration
SERIAL_PORT_PATH=/dev/serial0
SERIAL_BAUD_RATE=115200
SERIAL_PORT=/dev/serial0  

# Database Configuration
DB_USER=$DB_USER
DB_PASSWORD=$DB_PASSWORD
DB_NAME=$DB_NAME
DB_HOST=localhost
DB_PORT=5432

# TimescaleDB Configuration
TIMESCALE_USER=$DB_USER
TIMESCALE_PASSWORD=$DB_PASSWORD
TIMESCALE_NAME=${DB_NAME}_timescale
TIMESCALE_HOST=localhost
TIMESCALE_PORT=5432

# CORS Configuration
CORS_ORIGIN=http://${PI_IP_ADDRESS}:3000,http://localhost:3000,http://127.0.0.1:3000

# File Upload
UPLOAD_DIR=$APP_DIR/uploads
MAX_FILE_SIZE=5242880

# Logging
LOG_LEVEL=info
LOG_FILE=$APP_DIR/logs/app.log

# API
API_VERSION=v1

# Firebase Admin SDK
GOOGLE_APPLICATION_CREDENTIALS=$APP_DIR/backend/cbridge-1-firebase-adminsdk.json
DISABLE_FIREBASE=false
BYPASS_AUTH=false
NODE_ENV=production

# Docker Database Configuration
POSTGRES_USER=$DB_USER
POSTGRES_PASSWORD=$DB_PASSWORD
POSTGRES_DB=$DB_NAME
NEXT_PUBLIC_DISABLE_FIREBASE=false
NEXT_PUBLIC_DEMO_MODE=false
FIREBASE_SERVICE_ACCOUNT_PATH=./cbridge-1-firebase-adminsdk.json

# ==== MENDER OTA CONFIGURATION ====
MENDER_SERVER_URL=https://hosted.mender.io
MENDER_TENANT_TOKEN=$MENDER_TENANT_TOKEN
MENDER_DEVICE_TYPE=raspberrypi5

# ==== GPIO AND SERIAL CONFIGURATION ====
GPIO_ENABLED=true
UART_ENABLED=true

# ==== SD CARD ENCRYPTION ====
SD_CARD_DEVICE=/dev/mmcblk0
SD_MOUNT_POINT=/mnt/sd_encrypted
ENCRYPTION_KEY=$ENCRYPTION_KEY
FILE_ENCRYPTION_KEY=$FILE_ENCRYPTION_KEY

# ==== NODE WARNINGS SUPPRESSION ====
NODE_NO_WARNINGS=1
EOF

    chmod 600 .env .env.production
    print_status "Environment configuration created"
    print_info "Backend runs in production mode (NODE_ENV=production) with BYPASS_AUTH=true for dev-friendly setup"
    print_info "Production environment template created as .env.production"
}

# Install dependencies with proper error handling
install_dependencies() {
    print_step "Installing application dependencies..."
    
    # Install backend dependencies
    if [ -d "backend" ]; then
        print_info "Installing backend dependencies..."
        cd backend
        npm install --no-optional
        # Install missing dependencies that were discovered during manual setup
        print_info "Installing additional required packages..."
        npm install @google-cloud/firestore
        npm install serialport
        cd ..
        print_status "Backend dependencies installed"
    fi
    
    # Install frontend dependencies
    if [ -d "frontend" ]; then
        print_info "Installing frontend dependencies..."
        cd frontend
        npm install --no-optional
        cd ..
        print_status "Frontend dependencies installed"
    fi
    
    # Install GPIO dependencies
    print_info "Installing GPIO dependencies..."
    # Try multiple GPIO packages (different packages available on different systems)
    if sudo apt install -y pigpio python3-pigpio 2>/dev/null; then
        print_status "GPIO dependencies installed (pigpio)"
    elif sudo apt install -y python3-gpiod libgpiod-dev gpiod 2>/dev/null; then
        print_status "GPIO dependencies installed (gpiod)"
    elif sudo apt install -y python3-rpi.gpio 2>/dev/null; then
        print_status "GPIO dependencies installed (RPi.GPIO)"
    else
        print_warning "GPIO dependencies not available on this system"
    fi
    
    print_status "All dependencies installed"
}

# Initialize database with proper TimescaleDB handling
initialize_database() {
    print_step "Initializing database..."
    
    # Create database user first
    print_info "Creating database user $DB_USER..."
    sudo -u postgres psql -c "CREATE USER $DB_USER WITH PASSWORD '$DB_PASSWORD';" 2>/dev/null || print_info "User $DB_USER already exists"
    
    # Create database and grant permissions
    print_info "Creating database $DB_NAME..."
    sudo -u postgres psql -c "CREATE DATABASE $DB_NAME OWNER $DB_USER;" 2>/dev/null || print_info "Database $DB_NAME already exists"
    
    # Grant all privileges
    sudo -u postgres psql -c "GRANT ALL PRIVILEGES ON DATABASE $DB_NAME TO $DB_USER;"
    sudo -u postgres psql -c "ALTER USER $DB_USER CREATEDB;"
    
    # Grant schema permissions
    sudo -u postgres psql -d $DB_NAME -c "GRANT ALL ON SCHEMA public TO $DB_USER;"
    sudo -u postgres psql -d $DB_NAME -c "GRANT CREATE ON SCHEMA public TO $DB_USER;"
    
    print_status "Database and user created successfully"
    
    # Run initialization script if available
    if [ -f "backend/scripts/initialize-db.js" ]; then
        print_info "Running database initialization script..."
        cd backend
        node scripts/initialize-db.js
        cd ..
        print_status "Database initialized using existing script"
    else
        print_warning "Database initialization script not found, creating basic tables..."
        
        # Create basic tables using existing database configuration
        PGPASSWORD=$DB_PASSWORD psql -h localhost -U $DB_USER -d $DB_NAME << EOF
-- Create basic tables (following existing schema)
CREATE TABLE IF NOT EXISTS devices (
    id SERIAL PRIMARY KEY,
    device_id VARCHAR(255) UNIQUE NOT NULL,
    name VARCHAR(255),
    type VARCHAR(100),
    status VARCHAR(50),
    created_at TIMESTAMP DEFAULT NOW(),
    updated_at TIMESTAMP DEFAULT NOW()
);

CREATE TABLE IF NOT EXISTS light_states (
    id SERIAL PRIMARY KEY,
    device_id VARCHAR(255) NOT NULL,
    brightness INTEGER,
    color VARCHAR(7),
    state VARCHAR(20),
    created_at TIMESTAMP DEFAULT NOW(),
    FOREIGN KEY (device_id) REFERENCES devices(device_id)
);

CREATE TABLE IF NOT EXISTS scene_states (
    id SERIAL PRIMARY KEY,
    scene_id VARCHAR(255) NOT NULL,
    name VARCHAR(255),
    devices JSONB,
    created_at TIMESTAMP DEFAULT NOW()
);

-- Create TimescaleDB hypertables (following existing pattern)
CREATE TABLE IF NOT EXISTS device_logs (
    id SERIAL,
    device_id VARCHAR(255) NOT NULL,
    state JSONB NOT NULL,
    timestamp TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- Try to create hypertable, but don't fail if TimescaleDB is not available
DO \$\$
BEGIN
    PERFORM create_hypertable('device_logs', 'timestamp', if_not_exists => TRUE);
    RAISE NOTICE 'Created hypertable for device_logs';
EXCEPTION
    WHEN OTHERS THEN
        RAISE NOTICE 'Could not create hypertable for device_logs: %', SQLERRM;
END
\$\$;
EOF
        print_status "Basic database tables created"
    fi
}

# Configure GPIO and Serial with proper fixes
configure_gpio_serial() {
    print_step "Configuring GPIO and Serial communication..."
    
    # Add user to dialout group for serial access (CRITICAL FIX)
    print_info "Adding user to dialout group..."
    sudo usermod -a -G dialout $USER
    print_status "User added to dialout group"
    
    # Set serial port permissions
    print_info "Setting serial port permissions..."
    if [ -e "/dev/ttyAMA0" ]; then
        sudo chmod 666 /dev/ttyAMA0
        print_status "Permissions set for /dev/ttyAMA0"
    fi
    
    if [ -e "/dev/ttyAMA10" ]; then
        sudo chmod 666 /dev/ttyAMA10
        print_status "Permissions set for /dev/ttyAMA10"
    fi
    
    if [ -e "/dev/serial0" ]; then
        print_status "Serial0 symlink detected: $(readlink -f /dev/serial0)"
    fi
    
    # Configure boot settings for UART
    print_info "Configuring boot settings for UART..."
    
    # Enable UART in config.txt
    if grep -q "^enable_uart=1" /boot/firmware/config.txt 2>/dev/null; then
        print_info "UART already enabled in config.txt"
    else
        echo "enable_uart=1" | sudo tee -a /boot/firmware/config.txt >/dev/null
        print_status "UART enabled in config.txt"
    fi
    
    # Disable Bluetooth to free up main UART
    if grep -q "^dtoverlay=disable-bt" /boot/firmware/config.txt 2>/dev/null; then
        print_info "Bluetooth already disabled in config.txt"
    else
        echo "dtoverlay=disable-bt" | sudo tee -a /boot/firmware/config.txt >/dev/null
        print_status "Bluetooth disabled in config.txt (frees main UART)"
    fi
    
    # Disable serial console (login shell)
    print_info "Disabling serial console..."
    sudo systemctl disable serial-getty@ttyAMA0.service 2>/dev/null || print_info "Serial getty already disabled"
    sudo systemctl disable serial-getty@serial0.service 2>/dev/null || print_info "Serial getty already disabled"
    
    # Verify serial console is disabled in cmdline.txt
    if grep -q "console=serial\|console=ttyAMA" /boot/firmware/cmdline.txt 2>/dev/null; then
        print_warning "Serial console found in cmdline.txt - this should be removed manually"
        print_info "Edit /boot/firmware/cmdline.txt and remove console=serial0 or console=ttyAMA0"
    else
        print_status "Serial console not in cmdline.txt (correct)"
    fi
    
    # Enable GPIO and other interfaces
    print_info "Enabling SPI and I2C..."
    sudo raspi-config nonint do_spi 0 2>/dev/null || print_warning "Could not enable SPI via raspi-config"
    sudo raspi-config nonint do_i2c 0 2>/dev/null || print_warning "Could not enable I2C via raspi-config"
    
    # Check for existing serial ports
    print_info "Checking available serial ports..."
    if [ -e "/dev/ttyUSB0" ]; then
        print_status "USB serial port /dev/ttyUSB0 detected"
    fi
    
    if [ -e "/dev/ttyAMA0" ]; then
        print_status "GPIO UART port /dev/ttyAMA0 available"
    fi
    
    if [ -e "/dev/ttyAMA10" ]; then
        print_status "GPIO UART port /dev/ttyAMA10 available"
    fi
    
    # Create udev rule for persistent serial port permissions
    print_info "Creating udev rule for persistent serial permissions..."
    sudo tee /etc/udev/rules.d/99-serial-permissions.rules >/dev/null << 'UDEVRULE'
# Serial port permissions for C-Bridge
KERNEL=="ttyAMA[0-9]*", MODE="0666", GROUP="dialout"
KERNEL=="ttyUSB[0-9]*", MODE="0666", GROUP="dialout"
KERNEL=="serial[0-9]*", MODE="0666", GROUP="dialout"
UDEVRULE
    
    sudo udevadm control --reload-rules
    sudo udevadm trigger
    
    print_status "GPIO and Serial configured"
    print_warning "‚ö†Ô∏è  REBOOT REQUIRED for UART and serial configuration to take full effect"
}

# Set up Soft AP (Access Point) for WiFi Setup
setup_softap() {
    print_step "Setting up Soft AP for WiFi configuration..."
    
    # Install required packages
    print_info "Installing hostapd and dnsmasq..."
    sudo apt install -y hostapd dnsmasq
    
    # Stop services during configuration
    sudo systemctl stop hostapd 2>/dev/null || true
    sudo systemctl stop dnsmasq 2>/dev/null || true
    
    # Create softap scripts directory if not exists
    SOFTAP_DIR="${APP_DIR}/scripts/softap"
    if [ ! -d "$SOFTAP_DIR" ]; then
        print_warning "Softap scripts not found at $SOFTAP_DIR"
        print_info "Skipping softap setup - will need manual configuration"
        return 0
    fi
    
    # Make scripts executable
    print_info "Configuring softap scripts..."
    chmod +x "${SOFTAP_DIR}/setup-softap.sh" 2>/dev/null || true
    chmod +x "${SOFTAP_DIR}/auto-ap.sh" 2>/dev/null || true
    chmod +x "${SOFTAP_DIR}/wifi-setup-server.js" 2>/dev/null || true
    
    # Create state directory
    sudo mkdir -p /var/lib/cbridge
    sudo chown ${APP_USER}:${APP_USER} /var/lib/cbridge
    
    # Install the softap service
    print_info "Installing softap systemd service..."
    if [ -f "${SOFTAP_DIR}/cbridge-setup-ap.service" ]; then
        sudo cp "${SOFTAP_DIR}/cbridge-setup-ap.service" /etc/systemd/system/
        sudo systemctl daemon-reload
        sudo systemctl enable cbridge-setup-ap
        print_status "Softap systemd service installed and enabled"
    fi
    
    # Configure hostapd
    print_info "Configuring hostapd..."
    sudo tee /etc/hostapd/hostapd.conf > /dev/null << 'EOF'
# C-Bridge Soft AP Configuration
interface=wlan0
driver=nl80211
ssid=CBridge-Setup
hw_mode=g
channel=6
wmm_enabled=0
macaddr_acl=0
auth_algs=1
ignore_broadcast_ssid=0
wpa=2
wpa_passphrase=cbridge123
wpa_key_mgmt=WPA-PSK
wpa_pairwise=TKIP
rsn_pairwise=CCMP
EOF
    
    # Configure dnsmasq for DHCP
    print_info "Configuring dnsmasq..."
    sudo tee /etc/dnsmasq.conf > /dev/null << 'EOF'
# C-Bridge Soft AP DHCP Configuration
interface=wlan0
dhcp-range=192.168.4.10,192.168.4.50,255.255.255.0,24h
domain=cbridge.local
address=/cbridge.local/192.168.4.1
EOF
    
    # Unmask hostapd if needed
    sudo systemctl unmask hostapd 2>/dev/null || true
    
    # Don't start services yet - they'll be managed by auto-ap controller
    sudo systemctl disable hostapd 2>/dev/null || true
    sudo systemctl disable dnsmasq 2>/dev/null || true
    
    print_status "Soft AP configured (will start automatically when no WiFi is configured)"
    print_info "AP SSID: CBridge-Setup"
    print_info "AP Password: cbridge123"
    print_info "Setup URL: http://192.168.4.1:8080"
    print_info "SSH Access: ssh $USER@192.168.4.1 (when AP is active)"
    print_info "The AP will start automatically on boot if WiFi is not configured"
}

# Set up DS3231M RTC (Real-Time Clock)
setup_rtc() {
    print_step "Setting up DS3231M RTC (Real-Time Clock)..."
    
    # Enable I2C interface
    print_info "Enabling I2C interface..."
    
    # Check if raspi-config is available
    if command -v raspi-config &> /dev/null; then
        sudo raspi-config nonint do_i2c 0  # 0 = enable
    else
        # Manual configuration if raspi-config not available
        print_info "Manually configuring I2C..."
        
        # Enable I2C in /boot/config.txt
        if ! grep -q "^dtparam=i2c_arm=on" /boot/config.txt 2>/dev/null; then
            echo "dtparam=i2c_arm=on" | sudo tee -a /boot/config.txt
        fi
        
        # Load I2C modules
        if ! grep -q "^i2c-dev" /etc/modules 2>/dev/null; then
            echo "i2c-dev" | sudo tee -a /etc/modules
        fi
        if ! grep -q "^i2c-bcm2708" /etc/modules 2>/dev/null; then
            echo "i2c-bcm2708" | sudo tee -a /etc/modules
        fi
    fi
    
    # Install I2C tools
    print_info "Installing I2C tools..."
    sudo apt install -y i2c-tools
    
    # Add user to i2c group
    print_info "Adding ${APP_USER} to i2c group..."
    sudo usermod -a -G i2c ${APP_USER}
    
    # Load I2C kernel modules
    print_info "Loading I2C kernel modules..."
    sudo modprobe i2c-dev 2>/dev/null || true
    sudo modprobe i2c-bcm2708 2>/dev/null || true
    
    # Configure RTC device
    print_info "Configuring DS3231M RTC device..."
    
    # Add RTC device tree overlay
    if ! grep -q "^dtoverlay=i2c-rtc,ds3231" /boot/config.txt 2>/dev/null; then
        echo "dtoverlay=i2c-rtc,ds3231" | sudo tee -a /boot/config.txt
    fi
    
    # Create RTC initialization script
    sudo tee /usr/local/bin/init-rtc.sh > /dev/null << 'EOF'
#!/bin/bash
# Initialize DS3231M RTC

# Wait for I2C bus
sleep 2

# Check if RTC is detected
if i2cdetect -y 1 2>/dev/null | grep -q " 68 "; then
    echo "DS3231M RTC detected at 0x68"
    
    # Create RTC device if not exists
    if [ ! -e /dev/rtc0 ]; then
        echo ds3231 0x68 | sudo tee /sys/class/i2c-adapter/i2c-1/new_device
    fi
    
    # Read time from RTC
    sudo hwclock -r
    
    # Optionally sync system time from RTC if system time is not set
    if [ $(date +%Y) -lt 2020 ]; then
        echo "System time not set, syncing from RTC..."
        sudo hwclock -s
    fi
else
    echo "DS3231M RTC not detected on I2C bus"
fi
EOF
    
    chmod +x /usr/local/bin/init-rtc.sh
    
    # Create systemd service for RTC initialization
    sudo tee /etc/systemd/system/cbridge-rtc-init.service > /dev/null << EOF
[Unit]
Description=C-Bridge DS3231M RTC Initialization
After=local-fs.target
Before=timesync.target

[Service]
Type=oneshot
ExecStart=/usr/local/bin/init-rtc.sh
RemainAfterExit=yes

[Install]
WantedBy=multi-user.target
EOF
    
    # Enable the service
    sudo systemctl daemon-reload
    sudo systemctl enable cbridge-rtc-init.service
    
    print_status "RTC configured successfully"
    print_info "RTC will be initialized on next boot"
    print_info "Hardware connection:"
    print_info "  - Pin 3 (GPIO2) -> SDA"
    print_info "  - Pin 5 (GPIO3) -> SCL"
    print_info "  - Power: 3.3V and GND"
    print_warning "‚ö†Ô∏è  REBOOT REQUIRED for I2C and RTC to be fully initialized"
}

# Enable SSH service (for headless access via AP network)
enable_ssh() {
    print_step "Enabling SSH service for remote access..."
    
    # Enable and start SSH service
    sudo systemctl enable ssh 2>/dev/null || sudo systemctl enable sshd 2>/dev/null || true
    sudo systemctl start ssh 2>/dev/null || sudo systemctl start sshd 2>/dev/null || true
    
    # Create ssh file in boot partition (for Raspberry Pi OS - enables SSH on first boot)
    if [ -d "/boot" ] && [ ! -f "/boot/ssh" ]; then
        sudo touch /boot/ssh
        print_status "SSH enabled in boot partition"
    elif [ -d "/boot/firmware" ] && [ ! -f "/boot/firmware/ssh" ]; then
        sudo touch /boot/firmware/ssh
        print_status "SSH enabled in boot partition"
    fi
    
    # Verify SSH is running
    if systemctl is-active --quiet ssh 2>/dev/null || systemctl is-active --quiet sshd 2>/dev/null; then
        print_status "SSH service is running"
    else
        print_warning "SSH service may not be running - check manually"
    fi
    
    print_info "SSH access available at: ssh $USER@$(hostname -I | awk '{print $1}')"
    print_info "When AP is active, use: ssh $USER@192.168.4.1"
}

# Set up security features
setup_security() {
    print_step "Setting up security features..."
    
    # Enable SSH first
    enable_ssh
    
    # Configure firewall
    sudo apt install -y ufw
    sudo ufw allow ssh
    sudo ufw allow 3000/tcp  # Frontend
    sudo ufw allow 5000/tcp  # Backend API
    sudo ufw allow 8080/tcp  # WiFi Setup Server
    sudo ufw allow 80/tcp    # HTTP
    sudo ufw allow 443/tcp   # HTTPS
    sudo ufw --force enable
    
    # Install and configure fail2ban
    sudo apt install -y fail2ban
    sudo cp /etc/fail2ban/jail.conf /etc/fail2ban/jail.local
    
    # Configure fail2ban
    sudo tee -a /etc/fail2ban/jail.local << EOF

[DEFAULT]
bantime = 3600
findtime = 600
maxretry = 3

[sshd]
enabled = true
port = ssh
logpath = /var/log/auth.log
EOF
    
    sudo systemctl enable fail2ban
    sudo systemctl start fail2ban
    
    print_status "Security features configured"
}

# Set up monitoring and logging
setup_monitoring() {
    print_step "Setting up monitoring and logging..."
    
    # Create logs directory
    mkdir -p logs
    # Ensure proper permissions
    chown -R $USER:$USER logs 2>/dev/null || true
    
    # Set up log rotation
    sudo tee /etc/logrotate.d/cbridge << EOF
$APP_DIR/logs/*.log {
    daily
    missingok
    rotate 7
    compress
    delaycompress
    notifempty
    create 644 $USER $USER
    postrotate
        pm2 reloadLogs
    endscript
}
EOF
    
    # Create monitoring script
    cat > monitor.sh << 'EOF'
#!/bin/bash
echo "=== C-Bridge System Status ==="
echo "Date: $(date)"
echo ""

echo "=== Services Status ==="
pm2 status
echo ""

echo "=== Database Status ==="
sudo systemctl status postgresql --no-pager
echo ""

echo "=== Mender OTA Status ==="
sudo mender status
echo ""

echo "=== Encryption Status ==="
sudo cryptsetup status sd_encrypted 2>/dev/null || echo "SD encryption not active"
echo ""

echo "=== Disk Usage ==="
df -h
echo ""

echo "=== Memory Usage ==="
free -h
echo ""

echo "=== Network Connections ==="
netstat -tlnp | grep -E ':(3000|5000|5432)'
echo ""

echo "=== Recent Logs ==="
pm2 logs --lines 10
EOF

    chmod +x monitor.sh
    
    # Create security monitoring script
    sudo tee /usr/local/bin/security-monitor.sh << EOF
#!/bin/bash

LOG_FILE="$APP_DIR/logs/security.log"

log_security_event() {
    echo "\$(date '+%Y-%m-%d %H:%M:%S') - \$1" >> "\$LOG_FILE"
}

check_failed_logins() {
    local failed_count=\$(grep "Failed password" /var/log/auth.log | wc -l)
    if [ "\$failed_count" -gt 10 ]; then
        log_security_event "WARNING: High number of failed login attempts: \$failed_count"
    fi
}

check_network_connections() {
    local suspicious_conns=\$(netstat -tuln | grep -E ":(22|23|3389)" | wc -l)
    if [ "\$suspicious_conns" -gt 5 ]; then
        log_security_event "WARNING: Multiple suspicious network connections detected"
    fi
}

check_disk_space() {
    local disk_usage=\$(df $APP_DIR | tail -1 | awk '{print \$5}' | sed 's/%//')
    if [ "\$disk_usage" -gt 90 ]; then
        log_security_event "WARNING: Disk space usage is high: \${disk_usage}%"
    fi
}

while true; do
    check_failed_logins
    check_network_connections
    check_disk_space
    sleep 300
done
EOF

    sudo chmod +x /usr/local/bin/security-monitor.sh
    
    # Create systemd service for security monitoring
    sudo tee /etc/systemd/system/cbridge-security-monitor.service << EOF
[Unit]
Description=C-Bridge Security Monitor
After=network.target

[Service]
Type=simple
User=root
ExecStart=/usr/local/bin/security-monitor.sh
Restart=always
RestartSec=10

[Install]
WantedBy=multi-user.target
EOF

    sudo systemctl daemon-reload
    sudo systemctl enable cbridge-security-monitor
    sudo systemctl start cbridge-security-monitor
    
    print_status "Monitoring and logging configured"
}

# Build application
build_application() {
    print_step "Building application..."
    
    # Build frontend if it exists
    if [ -d "frontend" ]; then
        print_info "Building frontend for production..."
        cd frontend
        npm run build
        cd ..
        print_status "Frontend built"
    else
        print_warning "Frontend directory not found, skipping build"
    fi
}

# Create PM2 configuration
create_pm2_config() {
    print_step "Creating PM2 configuration..."
    
    cat > ecosystem.config.js << EOF
module.exports = {
  apps: [
    {
      name: 'cbridge-backend',
      script: 'backend/server.js',
      cwd: '$APP_DIR',
      env: {
        NODE_ENV: 'production',
        PORT: 5000
      },
      instances: 1,
      autorestart: true,
      watch: false,
      max_memory_restart: '1G',
      log_file: '$APP_DIR/logs/backend.log',
      out_file: '$APP_DIR/logs/backend-out.log',
      error_file: '$APP_DIR/logs/backend-error.log'
    },
    {
      name: 'cbridge-frontend',
      script: 'frontend/server.js',
      cwd: '$APP_DIR/frontend',
      env: {
        NODE_ENV: 'production',
        PORT: 3000
      },
      instances: 1,
      autorestart: true,
      watch: false,
      max_memory_restart: '1G',
      log_file: '$APP_DIR/logs/frontend.log',
      out_file: '$APP_DIR/logs/frontend-out.log',
      error_file: '$APP_DIR/logs/frontend-error.log'
    }
  ]
};
EOF

    print_status "PM2 configuration created"
}

# Create startup scripts
create_startup_scripts() {
    print_step "Creating startup scripts..."
    
    # Create development startup script
    cat > start-dev.sh << 'EOF'
#!/bin/bash
# C-Bridge Development Startup Script
set -e

echo "üöÄ Starting C-Bridge in Development Mode..."

# Kill any existing processes
pkill -f "node server.js" 2>/dev/null || true
pkill -f "npm run dev" 2>/dev/null || true
sleep 2

# Start backend in production mode with auth bypass
echo "Starting backend..."
cd backend
NODE_ENV=production BYPASS_AUTH=true node server.js &
BACKEND_PID=$!
cd ..

# Wait for backend to start
sleep 3

# Start frontend in development mode
echo "Starting frontend..."
cd frontend
npm run dev &
FRONTEND_PID=$!
cd ..

echo "‚úÖ C-Bridge started in development mode!"
echo "Frontend: http://localhost:3000"
echo "Backend: http://localhost:5000"
echo "Press Ctrl+C to stop"

# Cleanup function
cleanup() {
    echo "Stopping services..."
    kill $BACKEND_PID $FRONTEND_PID 2>/dev/null || true
    exit 0
}

trap cleanup SIGINT SIGTERM
wait
EOF

    # Create production startup script
    cat > start-prod.sh << 'EOF'
#!/bin/bash
# C-Bridge Production Startup Script
set -e

echo "üöÄ Starting C-Bridge in Production Mode..."

# Check for required files
if [ ! -f "backend/cbridge-1-firebase-adminsdk.json" ]; then
    echo "‚ö†Ô∏è  Firebase service account file not found!"
    echo "Please ensure backend/cbridge-1-firebase-adminsdk.json exists"
fi

# Use production environment
if [ -f ".env.production" ]; then
    cp .env.production .env
    echo "‚úÖ Using production environment"
else
    echo "‚ö†Ô∏è  Production environment file not found, using default .env"
fi

# Install dependencies if needed
if [ ! -d "backend/node_modules" ]; then
    echo "Installing backend dependencies..."
    cd backend && npm install --production && cd ..
fi

if [ ! -d "frontend/node_modules" ]; then
    echo "Installing frontend dependencies..."
    cd frontend && npm install --production && cd ..
fi

# Build frontend for production
if [ ! -d "frontend/.next" ]; then
    echo "Building frontend for production..."
    cd frontend && npm run build && cd ..
fi

# Start with PM2
if command -v pm2 &> /dev/null; then
    echo "Starting with PM2..."
    pm2 start ecosystem.config.js
    pm2 save
    echo "‚úÖ C-Bridge started in production mode with PM2!"
    echo "Frontend: http://localhost:3000"
    echo "Backend: http://localhost:5000"
    echo "Use 'pm2 status' to check status"
else
    echo "PM2 not found. Installing..."
    npm install -g pm2
    pm2 start ecosystem.config.js
    pm2 save
    pm2 startup
fi
EOF

    # Create mode switcher script
    cat > switch-mode.sh << 'EOF'
#!/bin/bash
# C-Bridge Mode Switcher Script

case "$1" in
    "dev"|"development")
        echo "üîÑ Switching to development mode..."
        cp .env .env.backup 2>/dev/null || true
        if [ -f ".env.development" ]; then
            cp .env.development .env
        else
            # Create development environment
            sed 's/BYPASS_AUTH=false/BYPASS_AUTH=true/g; s/NODE_ENV=production/NODE_ENV=development/g' .env.production > .env
        fi
        echo "‚úÖ Switched to development mode (authentication bypassed)"
        ;;
    "prod"|"production")
        echo "üîÑ Switching to production mode..."
        cp .env .env.backup 2>/dev/null || true
        if [ -f ".env.production" ]; then
            cp .env.production .env
        else
            echo "‚ùå Production environment file not found"
            exit 1
        fi
        echo "‚úÖ Switched to production mode (authentication enabled)"
        ;;
    *)
        echo "Usage: $0 {dev|development|prod|production}"
        echo ""
        echo "  dev, development  - Switch to development mode (auth bypassed)"
        echo "  prod, production  - Switch to production mode (auth enabled)"
        exit 1
        ;;
esac
EOF

    chmod +x start-dev.sh start-prod.sh switch-mode.sh
    
    print_status "Startup scripts created"
    print_info "Use ./start-dev.sh for development mode"
    print_info "Use ./start-prod.sh for production mode"
    print_info "Use ./switch-mode.sh dev|prod to switch modes"
}

# Start services with proper error handling
start_services() {
    print_step "Starting services..."
    
    # Start applications with PM2
    pm2 start ecosystem.config.js
    pm2 save
    pm2 startup
    
    print_status "Services started with PM2"
}

# Set up reverse proxy
setup_nginx() {
    print_step "Setting up Nginx reverse proxy..."
    
    sudo apt install -y nginx
    
    # Create Nginx configuration
    sudo tee /etc/nginx/sites-available/cbridge << EOF
server {
    listen 80;
    server_name _;

    location / {
        proxy_pass http://localhost:3000;
        proxy_http_version 1.1;
        proxy_set_header Upgrade \$http_upgrade;
        proxy_set_header Connection 'upgrade';
        proxy_set_header Host \$host;
        proxy_set_header X-Real-IP \$remote_addr;
        proxy_set_header X-Forwarded-For \$proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto \$scheme;
        proxy_cache_bypass \$http_upgrade;
    }

    location /api {
        proxy_pass http://localhost:5000;
        proxy_http_version 1.1;
        proxy_set_header Upgrade \$http_upgrade;
        proxy_set_header Connection 'upgrade';
        proxy_set_header Host \$host;
        proxy_set_header X-Real-IP \$remote_addr;
        proxy_set_header X-Forwarded-For \$proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto \$scheme;
        proxy_cache_bypass \$http_upgrade;
    }

    location /ws {
        proxy_pass http://localhost:5000;
        proxy_http_version 1.1;
        proxy_set_header Upgrade \$http_upgrade;
        proxy_set_header Connection "upgrade";
        proxy_set_header Host \$host;
        proxy_set_header X-Real-IP \$remote_addr;
        proxy_set_header X-Forwarded-For \$proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto \$scheme;
    }
}
EOF

    # Enable the site
    sudo ln -sf /etc/nginx/sites-available/cbridge /etc/nginx/sites-enabled/
    sudo rm -f /etc/nginx/sites-enabled/default
    sudo nginx -t
    sudo systemctl restart nginx
    sudo systemctl enable nginx
    
    print_status "Nginx reverse proxy configured"
}

# Verify installation
verify_installation() {
    print_step "Verifying installation..."
    
    # Check services
    echo "=== Service Status ==="
    pm2 status
    echo ""
    
    # Check database
    echo "=== Database Status ==="
    sudo systemctl status postgresql --no-pager
    echo ""
    
    # Check Mender
    echo "=== Mender OTA Status ==="
    sudo mender status
    echo ""
    
    # Check network
    echo "=== Network Status ==="
    netstat -tlnp | grep -E ':(3000|5000|5432|80)'
    echo ""
    
    # Test API
    echo "=== API Test ==="
    sleep 5  # Wait for services to start
    curl -s http://localhost:5000/api/health || echo "API not responding yet"
    echo ""
    
    print_status "Installation verification complete"
}

# Create final summary
create_summary() {
    print_header "INSTALLATION COMPLETE!"
    
    echo -e "${GREEN}üéâ C-Bridge has been successfully installed on your Raspberry Pi!${NC}"
    echo ""
    echo -e "${CYAN}üìã Installation Summary:${NC}"
    echo -e "   ‚úÖ Node.js $(node --version)"
    echo -e "   ‚úÖ PostgreSQL with TimescaleDB"
    echo -e "   ‚úÖ Security Features (Firewall, Fail2ban)"
    echo -e "   ‚úÖ Monitoring and Logging"
    echo -e "   ‚úÖ Nginx Reverse Proxy"
    echo -e "   ‚úÖ Application Services (PM2)"
    echo -e "   ‚úÖ Development Environment Configured"
    echo -e "   ‚ÑπÔ∏è  Mender OTA and SD Encryption: Configure separately for production"
    echo ""
    echo -e "${CYAN}üåê Access Your Application:${NC}"
    echo -e "   Detected IP Address: ${GREEN}${PI_IP_ADDRESS}${NC}"
    echo -e "   Frontend: http://${PI_IP_ADDRESS}:3000"
    echo -e "   Backend API: http://${PI_IP_ADDRESS}:5000"
    echo -e "   Nginx Proxy: http://${PI_IP_ADDRESS}"
    echo -e "   ${BLUE}Note: Environment is auto-configured for this IP${NC}"
    echo ""
    echo -e "${CYAN}üîß Management Commands:${NC}"
    echo -e "   Monitor: $APP_DIR/monitor.sh"
    echo -e "   PM2 Status: pm2 status"
    echo -e "   PM2 Logs: pm2 logs"
    echo -e "   Mender Status: sudo mender status"
    echo ""
    echo -e "${CYAN}üöÄ Startup Commands:${NC}"
    echo -e "   Development Mode: $APP_DIR/start-dev.sh"
    echo -e "   Production Mode: $APP_DIR/start-prod.sh"
    echo -e "   Switch Mode: $APP_DIR/switch-mode.sh {dev|prod}"
    echo ""
    echo -e "${CYAN}ÔøΩÔøΩ Database Credentials:${NC}"
    echo -e "   Database Name: $DB_NAME"
    echo -e "   Database User: $DB_USER"
    echo -e "   Database Password: $DB_PASSWORD"
    echo -e "   Credentials saved to: $CREDENTIALS_FILE"
    echo ""
    echo -e "${YELLOW}‚ö†Ô∏è  Important Notes:${NC}"
    echo -e "   1. ${RED}REBOOT REQUIRED${NC} for GPIO/Serial configuration to take effect"
    echo -e "   2. IP Address ${GREEN}${PI_IP_ADDRESS}${NC} auto-detected and configured"
    echo -e "   3. Serial port configured: UART enabled, Bluetooth disabled, console disabled"
    echo -e "   4. User added to dialout group for serial access"
    echo -e "   5. Serial port permissions set to 666 (read/write for all)"
    echo -e "   6. Firebase is already configured with existing credentials"
    echo -e "   7. Mender OTA client installed with tenant token (never expires)"
    echo -e "   8. For OTA updates: Get fresh API token from Mender dashboard when JWT expires"
    echo -e "   9. Set up SD card encryption manually if needed"
    echo -e "   10. All TimescaleDB and permission issues have been fixed"
    echo -e "   11. Backend runs in PRODUCTION MODE (NODE_ENV=production) for performance"
    echo -e "   12. BYPASS_AUTH=true set for dev-friendly access (no 401 errors)"
    echo -e "   13. Use ./switch-mode.sh prod to enable full production authentication"
    echo -e "   14. Database credentials are UNIQUE for this installation"
    echo -e "   15. CORS configured for detected IP, localhost, and 127.0.0.1"
    echo -e "   16. Setup uses current directory (${GREEN}${APP_DIR}${NC})"
    echo ""
    echo -e "${GREEN}üöÄ Your C-Bridge system is ready!${NC}"
    echo -e "${BLUE}üìã Next Steps:${NC}"
    echo -e "   1. Reboot the system"
    echo -e "   2. Run ./start-dev.sh to test in development mode"
    echo -e "   3. Run ./switch-mode.sh prod to enable production mode when ready"
}

# Main execution
main() {
    print_header "C-Bridge Development Environment Setup Script"
    echo -e "${BLUE}This script will set up C-Bridge development environment in the current directory${NC}"
    echo -e "${BLUE}Current directory: ${GREEN}${APP_DIR}${NC}"
    echo -e "${BLUE}Includes: Node.js, PostgreSQL, TimescaleDB, dependencies, and dev-friendly configuration${NC}"
    echo -e "${YELLOW}Note: Docker setup is separate - use docker setup script if needed${NC}"
    echo ""
    
    # Display detected IP address
    print_info "Detected Raspberry Pi IP Address: ${GREEN}${PI_IP_ADDRESS}${NC}"
    print_info "Environment will be auto-configured for this IP address"
    echo -e "${CYAN}Backend will run in production mode (NODE_ENV=production) with BYPASS_AUTH=true${NC}"
    echo ""
    
    # Confirm before proceeding
    read -p "Do you want to proceed with the development environment setup? (y/N): " -n 1 -r
    echo
    if [[ ! $REPLY =~ ^[Yy]$ ]]; then
        print_info "Setup cancelled by user"
        exit 0
    fi
    
    # Run all setup steps
    check_root
    check_sudo
    setup_database_credentials
    update_system
    install_nodejs
    install_database
    install_docker
    install_mender
    setup_encryption
    setup_application
    clone_repository
    create_environment
    install_dependencies
    initialize_database
    configure_gpio_serial
    setup_softap
    setup_rtc
    setup_security
    setup_monitoring
    build_application
    create_pm2_config
    create_startup_scripts
    start_services
    setup_nginx
    verify_installation
    create_summary
    
    print_header "SETUP COMPLETE!"
    echo -e "${GREEN}üéâ C-Bridge is now running on your Raspberry Pi!${NC}"
    echo -e "${YELLOW}Please reboot the system to complete GPIO/Serial configuration.${NC}"
}

# Run main function
main "$@"
